---
생성일자: 2024-03-08
tags:
  - najuha
---

# 참고
- 도메인 모델(조영호) https://www.youtube.com/watch?v=26S4VFUWlJM&t=3208s
- 우아한 객체지향(조영호) https://www.youtube.com/watch?v=dJ5C4qRqAgA&t=3037s

# 계층형 아키텍쳐

- 상위 레이어에서 하위레이어를 의존한다.
![[Pasted image 20240308012629.png]]

# 트랜잭션 스크립트 vs 도메인 모델

- 트랜잭션 스크립트: 빠른 개발에 유리함
	- 규모가 작은 토이프로젝트에서는 트랜잭션 스크립트방식의 문제점을 체감하기 어려움
- 도메인 모델: 유지보수 및 확장에 유리함

# request DTO 를 service 에서 사용해도 될까? (Controller와 Service 레이어의 강한 결합)

- 기본적으로는 안됨
- https://techblog.woowahan.com/2711/

# OrmEntity 에 도메인 로직을 구현해도 될까?

- 기본적으로는 안됨
	- 도메인은 외부 의존성 없이 순수한 상태로 유지하는게 좋음
- 김영한: 상황에 따라 다르다.
	- https://www.inflearn.com/questions/458968/jpa%EC%99%80-ddd%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EC%A7%88%EB%AC%B8-%EB%93%9C%EB%A6%BD%EB%8B%88%EB%8B%A4

# Entity 를 그대로 반환해도 될까?

- 안됨
	- api 마다 내보내야하는 정보가 다를텐데?
	- dto로 변환해서 내보내야함

# 클래스 의존성의 종류

![[Pasted image 20240329234313.png]]

## Association 연관관계
```ts
class A {
	private b: B;
}
```

## Dependency 의존관계
```ts
class A {
    method(b: B): B {
        return new B();
    }
}
```

## Inheritance 상속관계
```ts
class A extends B{
}
```

## Association 연관관계
```ts
class A implements B {
}
```


# 양방향 의존성을 피하자

- Bi-Directional 양방향
	A --> B
	B --> A
	
	```ts
	class A {
		private b: b;
	
		setA(b: B): void {
			this.b = b;
			this.b.setA(this);
		}
	}
	
	class B {
		private a: A;
	
		setA(a: A): void {
			this.a = a;
		}
	}
	```

- Uni-Directional 단 방향
	A --> B
	```ts
	class A {
		private b: b;
	
		setA(b: B): void {
			this.b = b;
		}
	}
	
	class B {
	}
	```

# 다중성이 적은 방향을 선택하자

- OneToMany 일대다
	`1 --> *`
	```ts
	class A {
		private bs: B[];
	}
	
	class B {
	}
	```

- ManyToOne 다대일
	`* --> 1`
	```ts
	class A {
	}
	
	class B {
	private a: A;
	}
	```

# 의존성이 필요없다면 제거하자

- Uni-Directional 단 방향
	A --> B
	```ts
	class A {
		private b: b;
	
		setA(b: B): void {
			this.b = b;
		}
	}
	
	class B {
	}
	```
	
- None 없음 
	```ts
	class A {
	}
	
	class B {
	}
	```

# 패키지(module) 사이의 의존성 사이클을 제거하라
![[Pasted image 20240330000106.png]]


# 관계의 방향 = 협력의 방향 = 의존성의 방향
![[Pasted image 20240330013647.png]]

# 관계의 종류 결정하기
- 연관 관계
![[Pasted image 20240330013732.png]]

- 의존 관계
![[Pasted image 20240330013759.png]]



# java 와 typescript의 차이점 

## java 특징
- normal typing
``` java
class A {
	name: string;
	age: number
	gender: string;
}

class B {
	name: string;
	age: number
}

const a: A = new A()
const b: B = new B(a.name, a.age);

A !== B
// A, B 내부 프로퍼티가 같아도 다른 타입으로 판단 됨
```

# typescript 특징
- structure typing
- literal object 
``` java
class A {
	name: string;
	age: number;
	gender: string;
}

class B {
	name: string;
	age: number;
}

const a: A = new A();
const b: B = A;

// A, B 내부 프로퍼티가 같으면 같은 타입으로 판단 됨
```


# DB Entity 와 Domain Entity 통합 or 분리

- 기본적으로 분리하는게 확장성, 유지보수에 좋음.
- 분리 했을때 장점
	- 순수한 도메인 코드 작성가능
	- orm 변경이 자유로움
	- orm 버그가 typeorm 에는 좀 많음
- 분리 했을때 단점
	- 중복된 코드 작성해야함.
	- orm 에서 지원하는 기능 jpaOrm (lazy loding, eager loding)  사용 못함

- 분리 안했을때 장점
	- 중복된 코드 줄어듬 
	- orm 에서 지원하는 기능 jpaOrm (lazy loding, eager loding)  사용 가능
	=> 빠른 개발 가능
- 분리 안했을때 단점
	- 도메인에 여러 외부 의존성이 생김
	- 비교적 수정과 확장에 제한적


? ts  structur typing 을 사용하면 어느정도 분리했을때 단점을 커버 가능하지 않을까?
- entity 안에 메서드


결론
- 도메인 객체 연관관계가 상황에 따라 다른게 문제
- 도메인 로직이 필요한경우에 대부분 도메인 객체 연관관계가 비슷비슷함
- 그럼 언제 도메인 객체 연관관계가 다르냐?
	- 읽기를 할때 연관관계가 다름
	- 대회 일정페이지- competition
	- 대회 상세 페이지 - competition.difision ... 



	
	
## 1. DB Entity 와 Domain Entity 통합

```ts
// user.entity.ts
@Entity()
export class UserEntity {
	@PrimaryGeneratedColumn()
	id: number

	@Column()
	name: string;
	//...

	updateName(newName: string) {
		// validate new name
		this.name = newName;
	}
}

// user.repository.ts
@Injectable()
export class UserRepository {
    constructor(
        @InjectRepository(UserEntity) private readonly userRepo: Repository<UserEntity>,
    ) {}

    async findById(id: number): Promise<UserEntity> {
        return await this.userRepo.findOne(id);
    }

    async save(user: UserEntity): Promise<UserEntity> {
        await this.userRepo.save(user);
        return user;
    }
}


// user.service.ts
@Injectable()
export class UserService {
	constructor() {}

	async updateUserName(userId:number, newName) {
		const user = this.userRepository.findById(userId);

		user.updateName(newName);

		this.userRepository.save(user);
		return user;
	}
}
```

## 2. DB Entity 와 Domain Entity 분리
```ts
// user.entity.ts
@Entity()
export class UserEntity {
    @PrimaryGeneratedColumn()
    id: number;

    @Column()
    name: string;

	posts: PostEntity[];
}

@Entity()
export class PostEntity {
    @PrimaryGeneratedColumn()
    id: number;

    @Column()
    title: string;
}

// user.domain-entity.ts
export class UserDomain {
    id: number;
    name: string;

    // constructor(id: number, name: string) {
    //     this.id = id;
    //     this.name = name;
    // }

    constructor(user: userEntity) {
	    if (user.posts) {
			this.posts = user.posts.map((post) => new PostDomain(post))
		}
    }

    // updateName(newName: string) {
		////  validate new name
    //     this.name = newName;
    // }
}

// post.domain-entity.ts
export class PostDomain {
    id: number;
    title: string;

    constructor(post) {
        this.id = id;
        this.title = title;
    }
}



// user.repository.ts
@Injectable()
export class UserRepository {
    constructor(
        @InjectRepository(UserEntity) private readonly userRepo: Repository<UserEntity>,
    ) {}

    async findMany(): Promise<UserDomain[]> {
        const user = await this.userRepo.findOne(
	        where: {id},
        );
    }

    async findById(id: number): Promise<UserDomain> {
        const user = await this.userRepo.findOne(
	        where: {id},
	        relations: ['posts']
        );
        return new UserDomain(user.name, user.id)
    }


    async findUserWithPost(id: number): Promise<UserDomain> {
        const user = await this.userRepo.findOne(
	        where: {id},
	        relations: ['posts']
        );
        return new UserDomain(user.name, user.id, posts: user.psot.map((post)=> new PostDomain(post.id, post.title))
        return new UserDomain(user);
    }

    async save(user: UserEntity): Promise<UserDomain> {
        await this.userRepo.save(user);
        return user;
    }
}

// user.service.ts
@Injectable()
export class UserService {
    constructor(private readonly userRepository: UserRepository) {}

    async updateUserName(userId: number, newName: string): Promise<User> {
        const user = await this.userRepository.findById(userId);

        if (user) {
            user.updateName(newName);
            await this.userRepository.save(user);
        }

        return user;
    }
}

```


# 상황에따라서 필요한 프로퍼티, relation 객체 가 다른 경우.

```ts
competitiion.divisions
competitiion
```

java 에서 기존 객체를 상속, 조합 을 통해서 새로운 객체를 만듬



ts 구조적 타이핑, 연관관계



``` ts
const {name, age, application, playername, playerAge..., a ,b c } = db.query(`slect name, age, ..`)
const payment = new Payment(a, b ,c) 
cosnt application = new application(playername, playerAge)
const user = new User(name, age);


const user = userRepository.getUser()

// db entity === domain model

@Entity
class User {
	name: string;
	age: number;
	application?: Application; 

	printAge() {
		console.log(this.age)
	}
}

class AService() {
	printUserAge() {
		const a: User = userRepository.getUser({name, age}, relations['application', 'payment']);


a.applicatioin?.printApplation;

a.payment.discount;

		a.printAge();
	}
	
	printUserAge() {
		const a: User = userRepository.getUser({name});
		a.printAge();
	}
}

// db entity, domain model 분리
@Entity
class UserEntity {
	name: string;
	age: number;
	application: Application;
}

@Entity
class ApplicaitonEntity {
	id: number;
}

@Entity
class ApplicationDomain {
	id: number;
}

class UserDomain {
	name: string;
	age: number;
	application :ApplicationEntity;

	printAge() {
		console.log(this.age)
	}
}

class UserwhitoutAgeDomain {
	name: string;
	application: ApplicationEntity;

	printUserWithoutAge() {
		console.log()
	}
}

class AService() {
	printUserAge() {
		const user = userRepository.getUser({name, age});
		const a: new UserDomain(name, age);
		a.printAge();
	}

	printUserWithoutAge() {
		const user = userRepository.getUser({name});
		const a: new UserWithoutAgeDomain(name);
		a.printAge();
	}
}

const a: User = getA(
{
name, age
}
)

const a-1: User = getA({
	name
})
```

domain model <--> DB entity

dto <--> domain model

dto to model
model to dto 
model to entity
entity to model


competition

competition-A
competition-B
competition-C



# 문제상황

1. 트랜잭션 스크립트
2. 상황에따른 entity, domain relation 불일치

## java 에서 해결 방법

1. 트랜잭션 스크립트
	- domain model 메서드로 도메인 로직을 포함

2. 상황에따른 db entity, domain relation 불일치
	- 상속을 통해 각 상황에 맞는 domain 객체를만듬
	- 

## ts 에서 해결 방법
- java
- 리터럴




# private 프로퍼티(캡슐화)가 필요한가?

# java 는 literal 객체가 없고, 구조적 타이핑을 않기 때문에 객체 지향적인 테크닉들이 발전되고 계승된거 아닐까?
	- dto, 도메인 모델을 class 로 정의
	- entity <--> dto mapper 사용

# anemic domain model 이 정말로 나쁜가?



# 상태와 행위


- 특정 도메인을 조회 할때는 인스턴스가 필요 없음
	- interface 로 만 정의해도 될듯
- 문제는 다른 도메인(객체)과 협력할때
	- `도메인_객체`, `협력_객체` 가 있다고 가정
	- 도메인에서 `도메인_객체`를 생성 및 수정 하기위해 `협력_객체`가 필요한 상황
	- 이때 `협력_객체`는 `도메인_객체`에게 자신이 어떤 데이터와, 어떤 메서드를 공개하고있는지 알려야함.




```ts
interface IA {
	name: string;

	someMethod(b: B): void{}
}

class A implements IA {
	name: string;

	someMethod(b: B) {
		b.printBName();
	}
}

class A_1 implements IA {
	name: string;

	someMethod(b: B) {
		consol.log("!!!!!!!!!!!!!!!");
		b.printBName();
	}
}

class A {
	constructor() {
	}

	someMethod(bName) {
		console.log(bName);
	}
}


```