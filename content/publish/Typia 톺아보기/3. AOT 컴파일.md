---
publish: true
생성일자: 2023-12-02
tags:
  - typescript/typia
---

# 참고
- [Typia AOT Compilation](https://typia.io/docs/pure/#aot-compilation)
- [AOT, Ahead-of-time compilation](https://en.wikipedia.org/wiki/Ahead-of-time_compilation)
- [typescript compiler api](https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function)
- [ts-patch](https://github.com/nonara/ts-patch#method-1-live-compiler)


# Typia AOT Compilation
typia 문서에 [AOT Compilation](https://typia.io/docs/pure/#aot-compilation) 글을 보면 아래와같이 설명되어있다.

> 누군가는 "순수한 TypeScript 타입"이라는 표현에 의문을 가질 수 있습니다.
> 
> > "여러분도 알다시피, TypeScript 타입은 JS로 컴파일될 때 어떠한 구체적인 인스턴스도 가지지 않습니다.
> > 
> > 그런데, 이러한 가상의 TypeScript 타입만으로 어떻게 `typia`가 런타임에 타입을 검증할 수 있나요? 어떻게 `typia`는 이러한 타입들만으로 훨씬 빠른 JSON 직렬화기를 구축할 수 있나요? 이런 것들이 `class-validator`나 `ajv`와 같은 추가적인 스키마 정의 없이 가능한가요?"
> 
> 제 대답은: "네, 가능합니다. 그 이유는 `typia`가 여러분의 서버 코드를 분석하고 AOT 컴파일을 수행하기 때문입니다."
> 
> 이러한 컴파일 시간 최적화는 AOT (Ahead of Time) 컴파일이라고 불립니다. 이것이 `typia`가 순수한 TypeScript 타입만으로 모든 것을 수행할 수 있는 비밀입니다. 아래 예제 코드를 읽고, JavaScript 파일이 어떻게 컴파일되는지 살펴보세요. 그러면 왜 `typia`가 더 쉽고, 더욱 빠른지 이해하게 될 것입니다.
> 
> - 런타임 검증기는 `class-validator`보다 **20,000배** 빠릅니다
> - JSON 직렬화는 `class-transformer`보다 **200배 빠릅니다**

일단 AOT Compile 에 대해 알아보자


# AOT, Ahead-of-time compilation

"AOT Compilation"은 "Ahead-of-Time Compilation"의 약자로, 프로그래밍에서 컴파일 과정을 일컫는 용어입니다. 이 방법에서는 프로그램이 실행되기 전에 소스 코드를 기계어 코드로 변환합니다. 이 과정은 프로그램의 실행 속도를 향상시키고, 실행 시간에 발생할 수 있는 컴파일 오버헤드를 줄입니다.

AOT 컴파일레이션의 주요 특징은 다음과 같습니다:

1. **성능 향상**: 실행 전에 모든 코드가 컴파일되기 때문에, 실행 시간에는 추가적인 컴파일 과정이 필요 없습니다. 이는 특히 반복적으로 사용되는 코드에 대해 빠른 실행 시간을 제공합니다.

2. **초기 시작 시간 감소**: JIT(Just-In-Time) 컴파일레이션과 비교했을 때, AOT 컴파일레이션은 초기 시작 시간을 단축시킵니다. JIT 컴파일레이션은 프로그램 실행 중에 코드를 컴파일하기 때문에 초기 로딩 시간이 더 길 수 있습니다.

3. **메모리 사용 최적화**: AOT 컴파일레이션은 실행 파일을 더 효율적으로 최적화할 수 있습니다. JIT 컴파일레이션의 경우, 런타임 중에 발생하는 메모리 오버헤드가 있을 수 있습니다.

4. **플랫폼 독립성**: 일부 AOT 컴파일러는 플랫폼에 독립적인 코드를 생성할 수 있으며, 이를 통해 다양한 시스템에서 코드를 실행할 수 있습니다.

5. **보안과 안정성**: AOT 컴파일레이션은 코드가 런타임에 변경되지 않는다는 장점을 가지고 있습니다. 이는 보안과 안정성 측면에서 이점을 제공합니다.

그러나 AOT 컴파일레이션에는 몇 가지 단점도 있습니다. 예를 들어, 특정 환경에 최적화된 코드를 생성하기 어렵고, 프로그램의 유연성이 다소 제한될 수 있습니다. 또한, 모든 코드를 미리 컴파일해야 하므로 컴파일 시간이 길어질 수 있습니다. 이러한 이유로, 많은 현대 언어와 환경에서는 AOT와 JIT 컴파일레이션을 혼합하여 사용하는 경우가 많습니다.


# TS -> JS 변환도 AOT 컴파일 인가?
TypeScript에서 JavaScript로 변환하는 과정은 엄밀히 말하면 전통적인 의미의 "AOT Compilation"이라고 부르기는 어렵습니다. 이는 TypeScript가 JavaScript로 변환되는 과정이 프로그래밍 언어의 전통적인 컴파일 과정과는 다소 다르기 때문입니다. 그러나 이 과정은 AOT 컴파일의 몇몇 개념과 유사한 점을 가지고 있습니다.

TypeScript는 JavaScript의 슈퍼셋으로, 타입 안정성과 클래스, 인터페이스와 같은 추가적인 기능을 제공합니다. TypeScript 코드는 직접적으로 브라우저나 Node.js 환경에서 실행될 수 없습니다. 그래서 TypeScript 코드는 JavaScript 코드로 "변환"되어야 합니다. 이 변환 과정은 TypeScript 컴파일러가 담당합니다.

이 과정을 AOT 컴파일과 비교해볼 때의 주요 차이점은 다음과 같습니다:

1. **언어 수준의 변환**: TypeScript에서 JavaScript로의 변환은 보다 높은 수준의 언어 기능을 제공하기 위한 것으로, 기본적으로 다른 언어로의 변환 과정입니다. 반면, 전통적인 AOT 컴파일은 동일 언어의 고수준 코드를 저수준의 기계 코드로 변환합니다.

2. **타겟 환경**: TypeScript의 변환 결과물인 JavaScript 코드는 여전히 인터프리터 언어입니다. JavaScript 코드는 브라우저나 Node.js에서 실행될 때 JIT(Just-In-Time) 컴파일 방식을 사용합니다. 이는 AOT 컴파일과는 다른 점으로, AOT는 실행 전에 모든 컴파일 과정을 완료합니다.

3. **목적**: TypeScript의 변환 과정의 주요 목적은 타입 안정성과 추가적인 언어 기능을 제공하는 것입니다. 반면, AOT 컴파일의 주요 목적은 보통 실행 시간의 성능 최적화입니다.

따라서 TypeScript의 변환 과정은 AOT 컴파일의 개념과 일부 유사하나, 더 넓은 의미에서 언어 수준의 변환 과정으로 이해하는 것이 적절합니다.

# 그러면 typia는 어떻게 컴파일에 관여하는거지?
[[1. typescript 컴파일 이해하기]]
[[2. typescript compiler api]]

## TypeScript Compiler API 활용

`typia`는 TypeScript의 Compiler API를 사용하여 AOT 컴파일을 구현합니다. 이 API를 통해 `typia`는 TypeScript 코드의 추상 구문 트리(AST)를 조작하고, 타입 정보를 분석하며, 사용자 정의 변환 로직을 적용합니다.

### 사용자 정의 변환기 예시

다음은 TypeScript Compiler API를 사용한 사용자 정의 변환기의 예시 코드입니다. 이 코드는 특정 함수 호출을 다른 함수로 변경하는 변환기를 구현합니다:

```ts
import * as ts from 'typescript';

function customTransformer<T extends ts.Node>(context: ts.TransformationContext) {
    return (rootNode: T) => {
        function visit(node: ts.Node): ts.VisitResult<ts.Node> {
            if (ts.isCallExpression(node) && node.expression.kind === ts.SyntaxKind.Identifier) {
                const identifier = node.expression as ts.Identifier;
                if (identifier.text === 'oldFunction') {
                    return ts.factory.createCallExpression(
                        ts.factory.createIdentifier('newFunction'),
                        undefined,
                        node.arguments
                    );
                }
            }
            return ts.visitEachChild(node, visit, context);
        }
        return ts.visitNode(rootNode, visit);
    };
}

export default customTransformer;

```

이 변환기는 모든 `oldFunction` 호출을 `newFunction`으로 변경합니다. TypeScript 컴파일러 API의 `visitEachChild` 함수를 사용하여 AST의 각 노드를 순회하고, 호출 표현식을 찾아 변환합니다.

## ts-patch의 역할 및 사용 방법

`ts-patch`는 TypeScript 컴파일러의 확장 기능을 제공하여, 사용자 정의 변환기를 쉽게 적용할 수 있게 해줍니다. 이 도구를 사용하면 복잡한 커스텀 빌드 스크립트 없이도, `tsconfig.json`을 통해 직접 변환기를 설정할 수 있습니다.

### ts-patch 없이 변환기 적용하기

`ts-patch` 없이 사용자 정의 변환기를 적용하려면, TypeScript 컴파일러 API를 직접 사용하는 추가적인 빌드 스크립트를 작성해야 합니다. 이 스크립트는 TypeScript 컴파일 과정을 명시적으로 제어하고, 필요한 변환기를 적용합니다.

### 빌드 스크립트 예시

```javascript
const ts = require('typescript');
const customTransformer = require('./customTransformer').default;

function compile(fileNames, options) {
    const program = ts.createProgram(fileNames, options);
    const emitResult = program.emit(undefined, undefined, undefined, undefined, {
        before: [customTransformer(program)]
    });

    // 오류 처리 및 진단 출력
    const allDiagnostics = ts.getPreEmitDiagnostics(program).concat(emitResult.diagnostics);
    allDiagnostics.forEach(diagnostic => {
        // 진단 정보 출력
    });

    const exitCode = emitResult.emitSkipped ? 1 : 0;
    process.exit(exitCode);
}

compile(['path/to/your/file.ts'], {
    noEmitOnError: true,
    noImplicitAny: true,
    target: ts.ScriptTarget.ES2015,
    module: ts.ModuleKind.CommonJS
});
```

이 스크립트는 명시적으로 TypeScript 컴파일러를 설정하고, 사용자 정의 변환기를 적용한 후, TypeScript 파일을 컴파일합니다.

### ts-patch를 사용한 변환기 적용

`ts-patch`를 사용하면, TypeScript 컴파일러를 수정하는 복잡한 과정 없이, `tsconfig.json` 파일 내에서 사용자 정의 변환기를 간단히 설정할 수 있습니다. 이는 개발자가 커스텀 빌드 스크립트를 작성하지 않고도 변환기를 적용할 수 있게 해줍니다.

#### tsconfig.json에서 사용자 정의 변환기 설정

`tsconfig.json` 파일에 다음과 같이 변환기를 설정할 수 있습니다:

```json
{
  "compilerOptions": {
    // 기타 컴파일러 옵션
    "plugins": [
      { "transform": "path/to/your-custom-transformer" }
    ]
  }
}
```

이 설정을 통해 TypeScript 컴파일 시 `customTransformer`가 자동으로 적용됩니다. 이 방법은 프로젝트 설정을 간편하게 유지하면서도 강력한 커스텀 변환 기능을 활용할 수 있게 해줍니다.


# 결론

`typia`의 AOT 컴파일 접근 방식은 TypeScript의 강력한 타입 시스템을 활용하여, 컴파일 시점에서 성능 최적화와 타입 검증 로직을 구축합니다. 이는 TypeScript의 Compiler API와 `ts-patch`를 통해 가능하며, 개발자에게 런타임 성능이 향상된, 타입 안전한 애플리케이션을 구축할 수 있는 강력한 도구를 제공합니다.

