---
생성일자: 2023-12-02
tags:
  - typescript/typia
---

# 원문
- [Typia Hidden Class Optimization of v8 Engine](https://dev.to/samchon/secret-of-typia-how-it-could-be-20000x-faster-validator-hidden-class-optimization-in-v8-engine-1mfb)

---

# javascript 에서 모든 객체는 해시맵
이해를 돕기 위해 비유적인 표현과 의사 코드를 많이 사용하겠습니다. 그러나 이러한 비유적 표현과 의사 코드는 실제 컴퓨터 공학 이론과 다소 다를 수 있습니다. 이러한 점을 고려하여 이 글을 읽어주시기 바랍니다.

동적 언어의 모든 객체는 해시맵이라는 말을 들어보셨나요?

타이피아가 어떻게 성능을 최적화하는지 알기 위해서는 이 개념을 이해해야 합니다. 동적 언어가 해시맵을 사용하는 이유와 해시맵이 어떻게 프로그램을 느리게 만드는지 알아보겠습니다.

```js
// in dynamic language like JavaScript,
const obj = {};

// you can any properties at any time
obj.a = "A";
obj.wafdfaf = 3;
obj[RandomGenerator.string()] = true;

// removing properties are also same
delete obj.a;
delete obj.wafdfaf;
```

## 자바스크립트는 동적 언어입니다.


따라서 변수에 모든 유형의 값을 할당할 수 있습니다. 객체의 경우 언제든지 속성을 추가하거나 삭제할 수도 있습니다.
동적 속성의 삽입과 삭제를 지원하려면 객체를 해시맵 타입으로 구현해야 합니다.

이것이 바로 동적 언어에서 객체에 해시맵을 사용하는 이유이며, 동적 언어에는 예외 사례가 없습니다. 파이썬, 루비, PHP 등 모든 동적 언어가 객체용 해시맵을 사용하고 있습니다.

 > [!note] 참고 -> [[동적 언어 vs 정적 언어]]

## HashMap 구현 방법
그런데 해시맵을 구현하는 방법을 알고 계신가요? 해시맵은 키-값 쌍을 링크드 리스트(C++ STL의 경우 이중 링크드 리스트)에 저장합니다. 또한 빠른 키 찾기를 위해 링크드 리스트의 노드를 버킷 배열에 저장합니다.  
  
이것이 바로 해시맵이 동적 언어를 느리게 만드는 이유입니다. 아시다시피 정적 언어는 배열처럼 고정되고 순서화된 메모리 공간에 객체 속성을 담습니다. 링크드 리스트와 배열의 반복 속도를 비교하면 어느 쪽이 더 빠를까요? 당연히 배열이 훨씬 빠릅니다. 이것이 동적 언어가 정적 언어보다 느린 근본적인 이유 중 하나입니다.  
  
동적 언어는 연결된 목록에 속성을 저장합니다.  
정적 언어는 프로퍼티를 배열(시퀀스 메모리 공간)에 저장합니다.  
제 설명이 이해하기 어렵다면 위의 의사 코드를 읽어보세요. 해시맵과 링크드 리스트의 실제 구현은 아니지만 개념을 이해하는 데 도움이 될 것입니다.

> [!faq] TreeMap 도 있는데 왜 HashMap 을 사용할까? 
>  - HashMap 검색, 삽입, 삭제 작업 시간복잡도 : O(1)
>  - TreeMap 검색, 삽입, 삭제 작업 시간복잡도 : O(log n)
> 1. **내부 구조**:
>    - `HashMap`: 키-값 쌍을 저장하기 위해 해시 테이블을 사용합니다. 이는 해시 함수를 통해 각 키에 대한 해시 코드를 계산하고, 이 코드를 사용하여 데이터를 저장합니다.
>    - `TreeMap`: 이진 검색 트리(대부분의 경우 레드-블랙 트리)를 사용하여 키-값 쌍을 저장합니다. 이는 키가 정렬된 순서로 저장되며, 트리의 균형을 유지합니다.
> 
> 2. **성능**:
>    - `HashMap`: 일반적으로 빠른 검색, 삽입, 삭제 작업을 제공합니다(O(1) 시간 복잡도). 그러나 해시 충돌이 발생하면 성능이 저하될 수 있습니다.
>    - `TreeMap`: 검색, 삽입, 삭제 작업에 대해 O(log n)의 시간 복잡도를 가집니다. 키가 정렬되어 있기 때문에 범위 검색과 정렬된 순서대로의 접근이 용이합니다.
> 
> 3. **정렬**:
>    - `HashMap`: 키의 순서는 정의되지 않습니다. 키-값 쌍의 순서는 해시 코드에 의해 결정되므로, 순서는 일정하지 않습니다.
>    - `TreeMap`: 키가 정렬되어 저장됩니다. 이는 순회할 때 정렬된 순서로 키-값 쌍에 접근할 수 있음을 의미합니다.
> 
> 4. **사용 사례**:
>    - `HashMap`: 키에 대한 빠른 접근이 필요하고 키의 순서가 중요하지 않은 경우에 적합합니다.
>    - `TreeMap`: 정렬된 순서로 키에 접근하거나 범위 기반의 쿼리가 필요한 경우에 유리합니다.

> [!faq] vector를 사용해서 HashMap을 구현할수도 있는데, linkedList로 HashMap을 구현해야 하나?
> 
> ==삽입, 삭제가 빈번한 동적언어에서는 linkedList 로 구현하는게 더 빠르다.==
> `Vector`(동적 배열)와 `LinkedList`의 검색, 삽입, 삭제 속도를 비교하면 다음과 같습니다
> 
> # **검색**
>    - `Vector` O(1) 시간 복잡도. 인덱스를 통해 직접 접근이 가능하기 때문에 빠른 검색 속도를 제공합니다.
>    - `LinkedList` O(n) 시간 복잡도. 리스트를 처음부터 끝까지 순회해야 하므로, 평균적으로 리스트의 절반 정도를 탐색해야 합니다.
> 
> # **삽입**
>    - `Vector` 평균적으로 O(1), 최악의 경우(재할당 및 복사가 필요할 때) O(n). 배열의 끝에 추가하는 경우 빠르지만, 중간에 삽입하는 경우 모든 요소를 이동시켜야 하므로 느려질 수 있습니다.
>    - `LinkedList` O(1) 시간 복잡도. 하지만 삽입 위치까지 도달하는 데 O(n)의 시간이 소요될 수 있습니다.
> 
> #  **삭제**
>    - `Vector` 중간 또는 앞부분에서 삭제하는 경우 O(n) 시간 복잡도. 끝에서 삭제하는 경우는 O(1).
>    - `LinkedList` O(1) 시간 복잡도. 하지만 삭제할 노드에 도달하는 데 O(n)의 시간이 필요합니다.
> 
> #  **결론**
> 이러한 차이점을 고려할 때, 검색이 주된 작업인 경우 `Vector`가 적합하며, 삽입과 삭제가 빈번한 경우에는 `LinkedList`가 더 유리할 수 있습니다.

## `HashMap` class exmple

```ts
export class HashMap<Key, T> {
    private hasher_: (key: Key) => number;
    private equal_: (x: Key, y: Key) => number;

    // HashMap stores its key-value pairs into a Linked List
    private data_: List<Entry<Key, T>>;

    // Instead, have bucket array of linked list nodes, for fast key finding
    private buckets_: List.Node<Entry<Key, T>>[][];

    private find(key: Key): List.Node<Entry<Key, T>> {
        const hash: number = this.hasher_(key);
        const index: number = hash % this.buckets_.length;
        const bucket: List.Node<Entry<Key, T>>[] = this.buckets_[index] ?? [];

        return bucket.find(
            (node) => this.equal_(node.value.key, key)
        ) ?? this.data_.end();
    }

    // Therefore, single key access could be faster
    public has(key: Key): boolean {
        this.find(key) !== this.data_.end();
    }

    public get(key: Key): T | undefined {
        const it: List.Node<Entry<Key, T>> = this.find(key);
        return it !== this.data_.end() 
            ? it.value.value 
            : undefined;
    }

    // However, full iteration is slower as well as linked list
    public entries(callback: (value: [Key, T]) => void): void {
        let it: List.Node<Entry<Key, T>> = this.data_.begin();
        while (it !== this.data_.end()) {
            callback([it.value.key, it.value.value]);
            it = it.next();
        }
    }

    public size(): number { return this.data_.size(); }
}

export class List<T> {
    private begin_: List<T>; 
    private end_: List<T>;
    private size_: number;

    public size(): number;
    public begin(): List.Node<T>;
    public end(): List.Node<T>;
}
export namespace List {
    export class Node<T> {
        public next: Node<T> | null;
        public prev: Node<T> | null;
        public value: T;
    }
}
```

---

# V8 Engine Hidden Class Optimization

> [!note] 참고
> - [[1. javascript 작동 방식 (V8 엔진의 내부)]]
> - [[2. javascript 성능의 비밀 (V8 Engine & Hidden Classes)]]

지금까지 동적 언어가 동적 키 구성을 위해 해시맵을 사용한다는 사실을 알아봤는데, 해시맵은 저장소인 링크드 리스트 때문에 프로그램 속도가 느려지는 단점이 있습니다. 그런데 v8 엔진에는 이 문제를 해결하기 위한 특별한 최적화 기술이 있습니다.  
  
==v8 엔진은 프로퍼티의 구성이 고정된 객체 유형을 감지하면 해당 객체 유형에 대한 히든 클래스 정의를 만듭니다. 그리고 이 히든 클래스 정의는 해시맵을 사용하지 않고 정적 언어처럼 프로퍼티를 고정되고 순서화된 메모리 공간에 배열합니다.==
  
이를 "히든 클래스 최적화"라고 합니다. 구글 크롬이나 노드JS가 다른 동적 언어나 자바 같은 일부 정적 언어보다 훨씬 빠르다고 들었다면, 히든 클래스 최적화가 주된 이유 중 하나라고 생각해도 좋습니다.

![[Pasted image 20231203185053.png]]


# 요약

이 글에서 배운 내용을 요약해 보겠습니다:

1. 동적 언어에서는 동적 프로퍼티의 삽입과 삭제를 지원하기 위해 해시맵을 사용하고 있습니다.
2. 해시맵은 키-값 쌍을 링크드 리스트 컨테이너에 저장하므로 프로그램의 속도가 느려집니다.
3. 또한 정적 언어는 프로퍼티를 배열과 같이 고정되고 순서화된 메모리 공간에 저장하므로 프로그램 속도가 빨라집니다.
4. v8 엔진의 경우, 해시맵에서 벗어나 정적 언어처럼 고정되고 순차적인 메모리 공간에 프로퍼티를 저장하기 위해 "히든 클래스 최적화"라는 특별한 최적화 기법이 있습니다.

# typia가 가장 빠른이유
타이피아가 클래스 유효성 검사기보다 빠른 이유도 위에 정리한 이론적 내용과 크게 다르지 않습니다. 저는 타이피아를 설계할 때 v8 엔진에 유리한 코드를 생성하도록 했고, 실제로 타이피아로 생성된 코드는 히든 클래스 최적화의 이점을 누리고 있습니다.

게다가 class-validator와 class-transform은 항상 직렬화 및 유효성 검사 로직을 동적 프로퍼티의 접근, 특히 `Reflect`로 대표되는 접근을 통해 구성합니다. 따라서 클래스 유효성 검사기와 클래스 변환은 숨겨진 클래스 최적화의 이점을 결코 얻을 수 없으며 항상 느린 링크드 리스트 노드를 반복합니다.

20,000배의 속도 격차도 이러한 차이에서 비롯된 것입니다. 일반적으로 배열과 링크드 리스트의 탐색 속도는 약 10배 정도 차이가 납니다. 클래스 유효성 검사기와 클래스 트랜스포머는 동적 키 액세스에 대해 두 배에서 네 배까지 중첩된 반복을 수행하므로 이론적으로 10배의 차이는 최대 (104 = 10,000)x로 증가합니다.
